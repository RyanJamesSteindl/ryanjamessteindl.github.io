<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Victron Mapped Dashboard</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles and variable definitions */
        :root {
            --bg: #0d1117;
            --card-bg: #161b22;
            --text: #c9d1d9;
            --accent: #238636;
            --danger: #da3633;
            --warning: #f2cc0b;
            --info: #58a6ff;
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg); color: var(--text); }
        .data-card { background-color: var(--card-bg); border-radius: 0.5rem; padding: 1.25rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -2px rgba(0, 0, 0, 0.1); transition: transform 0.2s; }
        .data-card:hover { transform: translateY(-2px); }
        .data-label { color: var(--text); opacity: 0.7; font-size: 0.875rem; }
        .data-value { font-size: 1.75rem; font-weight: 700; color: #fff; line-height: 1; }
        .btn-connect { background-color: var(--accent); color: white; border: none; padding: 10px 20px; border-radius: 0.5rem; transition: background-color 0.3s; }
        .btn-connect:hover:not(:disabled) { background-color: #3b9e4a; }
        .status-box { padding: 8px; border-radius: 0.5rem; margin-top: 10px; font-weight: 600; text-align: center; }
        .status-connecting { background-color: var(--info); color: var(--bg); }
        .status-error { background-color: var(--danger); color: white; }
        .status-streaming { background-color: var(--accent); color: white; }
        .status-disconnected { background-color: #333; color: var(--text); }
        
        /* Responsive Grid for mobile */
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 1rem; }

        @keyframes pulse-stream {
            0% { box-shadow: 0 0 0 0 rgba(35, 134, 54, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(35, 134, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(35, 134, 54, 0); }
        }
        .streaming-indicator {
            animation: pulse-stream 1.5s infinite;
        }
        
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold mb-6 text-center text-white">Victron Energy Dashboard</h1>
        
        <!-- Connection Panel -->
        <div class="data-card mb-6">
            <h2 class="text-xl font-semibold mb-3 text-white">Device Connection</h2>
            
            <input type="text" id="keyInput" placeholder="Paste 32-char Hex Encryption Key (e.g., 0123...CDEF)" 
                   class="w-full p-3 mb-4 bg-gray-800 border border-gray-700 rounded-lg text-sm text-white focus:ring-blue-500 focus:border-blue-500" />
            
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="connectBtn" class="btn-connect flex-grow font-bold text-lg" onclick="handleConnect()">
                    Connect & Start Stream
                </button>
                <button id="disconnectBtn" class="btn-connect flex-grow font-bold text-lg opacity-50" onclick="handleDisconnect()" disabled>
                    Disconnect
                </button>
            </div>
            
            <div id="statusDisplay" class="status-box status-disconnected">
                Status: Ready to connect.
            </div>
        </div>

        <!-- Metrics Display -->
        <div id="metricsDisplay" class="metrics-grid">
            <!-- Data Cards will be updated here by JavaScript -->
            <div id="V" class="data-card"><div class="data-label">Voltage (V)</div><div class="data-value">--</div></div>
            <div id="I" class="data-card"><div class="data-label">Current (A)</div><div class="data-value">--</div></div>
            <div id="P" class="data-card"><div class="data-label">Power (W)</div><div class="data-value">--</div></div>
            <div id="SOC" class="data-card"><div class="data-label">State of Charge (%)</div><div class="data-value">--</div></div>
            <div id="T" class="data-card"><div class="data-label">Temperature (C)</div><div class="data-value">--</div></div>
            <div id="H19" class="data-card"><div class="data-label">Yield Today (kWh)</div><div class="data-value">--</div></div>
        </div>

        <!-- Raw Data Debug (Optional) -->
        <div class="mt-8 data-card">
            <h3 class="text-lg font-semibold mb-2 text-white">Raw VE.Direct Data</h3>
            <pre id="rawData" class="bg-gray-800 p-3 rounded-lg text-xs overflow-auto h-32 text-gray-400"></pre>
        </div>
        
    </div>

<script>
    // --- Application Constants ---
    const APP_VERSION = "7.0.2";
    // Victron Manufacturer ID
    const VICTRON_MANUFACTURER_ID = 0x02E1; 
    // Victron Service and Characteristic UUIDs
    const VICTRON_SERVICE_UUID = "0000a000-0000-1000-8000-00805f9b34fb";
    const WRITE_CHARACTERISTIC_UUID = "0000a001-0000-1000-8000-00805f9b34fb";
    const NOTIFY_CHARACTERISTIC_UUID = "0000a002-0000-1000-8000-00805f9b34fb";
    // Characteristic to send the encryption key to
    const AUTH_CHARACTERISTIC_UUID = "0000a004-0000-1000-8000-00805f9b34fb"; 

    // --- State Variables ---
    let device = null;
    let server = null; 
    let notifyCharacteristic = null;
    let writeCharacteristic = null;
    let cryptoKey = null; 
    let veDirectBuffer = new Uint8Array(0);

    // --- DOM Elements ---
    const statusDisplay = document.getElementById('statusDisplay');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const keyInput = document.getElementById('keyInput');
    const rawDataEl = document.getElementById('rawData');
    const metricsDisplay = document.getElementById('metricsDisplay');

    // --- Utility Functions (AES) ---

    /** Generates an AES-128 key from the 32-character hex key string. */
    async function generateCryptoKey(hexKey) {
        if (hexKey.length !== 32) {
            throw new Error("Key must be 32 characters long (16 bytes).");
        }
        const keyBytes = new Uint8Array(hexKey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
        return window.crypto.subtle.importKey(
            "raw",
            keyBytes,
            { name: "AES-CBC", length: 128 },
            false,
            ["encrypt", "decrypt"]
        );
    }

    /** Decrypts a Victron notification payload (16 bytes). */
    async function decryptPayload(encryptedBuffer, key) {
        // IV is always 16 zero bytes for the Victron AES-128-CBC implementation
        const iv = new Uint8Array(16); 
        
        try {
            const decryptedBuffer = await window.crypto.subtle.decrypt(
                { name: "AES-CBC", iv: iv },
                key,
                encryptedBuffer
            );
            return new Uint8Array(decryptedBuffer);
        } catch (error) {
            console.error("Decryption failed:", error);
            throw new Error("Decryption failed. Check key or data integrity.");
        }
    }

    // --- VE.Direct Protocol Parsing ---

    /** Parses a single VE.Direct data frame. */
    function parseVeDirectFrame(data) {
        const records = {};
        const textDecoder = new TextDecoder('utf-8');
        const text = textDecoder.decode(data);
        const lines = text.split('\r\n').filter(line => line.includes('\t'));
        
        lines.forEach(line => {
            const parts = line.split('\t');
            if (parts.length === 2) {
                const label = parts[0].trim();
                const value = parts[1].trim();
                records[label] = value;
            }
        });

        return records;
    }

    // --- Data Handling and Display ---

    /** Updates the main metrics display cards. */
    function updateMetricsDisplay(records) {
        const mappings = {
            'V': { unit: 'V', factor: 1000 },
            'I': { unit: 'A', factor: 1000 },
            'P': { unit: 'W', factor: 1 },
            'SOC': { unit: '%', factor: 10 },
            'T': { unit: 'C', factor: 100 }, 
            'H19': { unit: 'kWh', factor: 100 }, 
        };

        let isDataPresent = false;

        for (const [key, map] of Object.entries(mappings)) {
            const el = document.getElementById(key);
            if (el && records[key] !== undefined) {
                isDataPresent = true;
                const rawValue = parseInt(records[key], 10);
                let displayValue;
                
                const factor = map.factor;
                displayValue = (rawValue / factor).toFixed(key === 'SOC' || key === 'T' ? 1 : 2);
                
                el.querySelector('.data-value').innerText = `${displayValue} ${map.unit}`;
            }
        }
        
        if (isDataPresent) {
            metricsDisplay.classList.add('streaming-indicator');
            setTimeout(() => {
                metricsDisplay.classList.remove('streaming-indicator');
            }, 300);
        }
        
        // Update raw data log
        rawDataEl.innerText = JSON.stringify(records, null, 2);
    }

    /** Main handler for incoming Bluetooth notifications (Encrypted data chunks). */
    async function handleNotifications(event) {
        const encryptedData = new Uint8Array(event.target.value.buffer);
        
        try {
            // 1. Decrypt the 16-byte chunk
            const decryptedChunk = await decryptPayload(encryptedData.buffer, cryptoKey);
            
            // 2. Append to the global VE.Direct buffer
            const newBuffer = new Uint8Array(veDirectBuffer.length + decryptedChunk.length);
            newBuffer.set(veDirectBuffer);
            newBuffer.set(decryptedChunk, veDirectBuffer.length);
            veDirectBuffer = newBuffer;
            
            // 3. Check for the VE.Direct end-of-frame marker (CR LF CR LF)
            const fullText = new TextDecoder().decode(veDirectBuffer);
            const frameIndex = fullText.indexOf('\r\n\r\n');

            if (frameIndex !== -1) {
                const frameEnd = frameIndex + 4; 
                const fullFrame = veDirectBuffer.slice(0, frameEnd);
                
                const records = parseVeDirectFrame(fullFrame);
                updateMetricsDisplay(records);
                
                veDirectBuffer = veDirectBuffer.slice(frameEnd);
            }

        } catch (error) {
            console.error("Error processing data stream:", error.message);
            // Don't stop the stream on a data error, just log it.
        }
    }
    
    /** Writes the encryption key to the authentication characteristic. */
    async function authenticateDevice() {
        if (!server) throw new Error("GATT Server not connected.");
        
        updateStatus("Authenticating device...", 'connecting');

        try {
            // 1. Get the authentication characteristic
            const authService = await server.getPrimaryService(VICTRON_SERVICE_UUID);
            const authCharacteristic = await authService.getCharacteristic(AUTH_CHARACTERISTIC_UUID);

            // 2. Prepare the 16 bytes key
            const hexKey = keyInput.value.trim().toUpperCase();
            const keyBytes = new Uint8Array(hexKey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            
            // 3. Write the key
            await authCharacteristic.writeValue(keyBytes);

            updateStatus("Authentication successful.", 'connecting');

        } catch (error) {
            // Check for specific error types to provide better diagnostics
            if (error.name === 'NotFoundError') {
                if (error.message.includes(AUTH_CHARACTERISTIC_UUID.toUpperCase())) {
                    throw new Error("Authentication Characteristic (a004) not found on device.");
                } else if (error.message.includes(VICTRON_SERVICE_UUID.toUpperCase())) {
                    throw new Error("Victron Service (a000) not found (requires key to be written to a different service).");
                }
            }
            // Generic write failure (usually key rejection)
            throw new Error(`Key Write Failed: ${error.message}`);
        }
    }

    // --- Bluetooth Connection Logic ---

    /** Sets the UI status message. */
    function updateStatus(message, type = 'disconnected') {
        statusDisplay.innerText = `Status (v${APP_VERSION}): ${message}`;
        statusDisplay.className = 'status-box'; // Reset classes

        if (type === 'connecting') {
            statusDisplay.classList.add('status-connecting');
            connectBtn.disabled = true;
            disconnectBtn.disabled = true;
            keyInput.disabled = true;
        } else if (type === 'streaming') {
            statusDisplay.classList.add('status-streaming');
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            keyInput.disabled = true;
        } else if (type === 'error') {
            statusDisplay.classList.add('status-error');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            keyInput.disabled = false;
        } else { // disconnected
            statusDisplay.classList.add('status-disconnected');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            keyInput.disabled = false;
        }
    }

    /** Starts monitoring the notification characteristic. */
    async function startMonitoring() {
        if (!notifyCharacteristic) {
            updateStatus("Notification characteristic not found.", 'error');
            return;
        }

        updateStatus("Starting notifications and sending initialization command...", 'connecting');

        notifyCharacteristic.addEventListener('characteristicvaluechanged', handleNotifications);
        
        await notifyCharacteristic.startNotifications();
        
        // Send the initialization command (AT+OK\r\n) to trigger data flow
        const commandText = "AT+OK\r\n";
        const encoder = new TextEncoder();
        const commandBuffer = encoder.encode(commandText);
        
        await writeCharacteristic.writeValue(commandBuffer);

        updateStatus("Streaming Data", 'streaming');
    }

    /** Handles the main connection workflow. */
    window.handleConnect = async function() {
        if (!navigator.bluetooth) {
            updateStatus("Web Bluetooth not supported in this browser/environment.", 'error');
            return;
        }

        const hexKey = keyInput.value.trim().toUpperCase();
        if (hexKey.length !== 32 || !/^[0-9A-F]{32}$/.test(hexKey)) {
            updateStatus("Please enter a valid 32-character hex key.", 'error');
            return;
        }
        
        updateStatus("Generating encryption key...", 'connecting');
        try {
            cryptoKey = await generateCryptoKey(hexKey);
        } catch(e) {
            updateStatus(`Invalid Key Format: ${e.message}`, 'error');
            return;
        }

        updateStatus("Searching for Victron devices...", 'connecting');
        
        try {
            // 1. Request device using the strict manufacturer filter
            device = await navigator.bluetooth.requestDevice({
                optionalServices: [VICTRON_SERVICE_UUID], 
                filters: [{
                    manufacturerData: [{
                        companyIdentifier: VICTRON_MANUFACTURER_ID
                    }]
                }]
            });

            device.addEventListener('gattserverdisconnected', handleDisconnect);
            
            updateStatus(`Connecting to ${device.name}...`, 'connecting');
            server = await device.gatt.connect(); 

            // 2. AUTHENTICATE DEVICE IMMEDIATELY
            await authenticateDevice(); 
            
            // 3. Get the data service and characteristics
            updateStatus("Getting data service...", 'connecting');
            const service = await server.getPrimaryService(VICTRON_SERVICE_UUID);

            updateStatus("Getting data characteristics...", 'connecting');
            notifyCharacteristic = await service.getCharacteristic(NOTIFY_CHARACTERISTIC_UUID);
            writeCharacteristic = await service.getCharacteristic(WRITE_CHARACTERISTIC_UUID);

            // 4. Start the stream
            await startMonitoring();

        } catch (error) {
            console.error("Connection Error:", error);
            let message = error.message || 'Unknown error';
            
            if (error.name === 'NotFoundError') {
                message = "Search canceled or no Victron devices found nearby. Check range/permissions.";
            } else if (error.name === 'SecurityError') {
                 message = "Security Error: Ensure Location/Bluetooth is ON and you are using HTTPS.";
            } else if (message.includes('No Services with UUID')) {
                 message = "Device found but required Victron service is unavailable. Check device power/range.";
            } else if (message.includes('GATT operation failed for unknown reason')) {
                 message = "Authentication or GATT service access failed. Verify device key or retry.";
            } else if (message.includes('Authentication Characteristic')) {
                 message = `Auth Failed: ${message}`;
            } else if (message.includes('Victron Service')) {
                 message = `Auth Failed: ${message}`;
            } else if (message.includes('Key Write Failed')) {
                 message = `Auth Failed: ${message}. Check key accuracy.`;
            }

            updateStatus(`Connection Failed: ${message}`, 'error');
            handleDisconnect(true); 
        }
    }

    /** Handles device disconnection. */
    window.handleDisconnect = function(silent = false) {
        if (device && device.gatt && device.gatt.connected) {
            device.gatt.disconnect();
        }
        
        if (notifyCharacteristic) {
            notifyCharacteristic.removeEventListener('characteristicvaluechanged', handleNotifications);
        }

        device = null;
        server = null;
        notifyCharacteristic = null;
        writeCharacteristic = null;
        cryptoKey = null;
        veDirectBuffer = new Uint8Array(0);
        
        if (!silent) {
            updateStatus("Disconnected. Ready to try again.", 'disconnected');
        }
        
        // Reset the raw data and metrics
        rawDataEl.innerText = "No data streaming.";
        document.querySelectorAll('.data-value').forEach(el => el.innerText = '--');
    }

    // Initialize state on load
    window.onload = () => {
        updateStatus("Ready to connect");
        // Pre-fill key from last session if available (using localStorage is okay here)
        const savedKey = localStorage.getItem('victron_key');
        if (savedKey) keyInput.value = savedKey;
        
        // Save key on input change
        keyInput.addEventListener('input', () => {
            localStorage.setItem('victron_key', keyInput.value.trim());
        });
    };

    // Global cleanup handler (optional but good practice)
    window.onbeforeunload = window.handleDisconnect;

</script>
</body>
</html>

