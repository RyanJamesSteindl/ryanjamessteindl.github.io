<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Victron SOC Monitor</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #333; text-align: center; padding: 20px; }
        .container { max-width: 400px; margin: 0 auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1 { font-size: 1.5rem; margin-bottom: 20px; color: #2c3e50; }
        input { width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 8px; box-sizing: border-box; font-family: monospace; }
        button { width: 100%; padding: 15px; background-color: #3498db; color: white; border: none; border-radius: 8px; font-size: 1.1rem; font-weight: bold; cursor: pointer; }
        button:disabled { background-color: #bdc3c7; }
        .soc-display { font-size: 3.5rem; font-weight: bold; margin: 30px 0; color: #27ae60; }
        .log { font-size: 0.8rem; color: #7f8c8d; margin-top: 20px; text-align: left; height: 100px; overflow-y: auto; border-top: 1px solid #eee; padding-top: 10px; }
        .status { font-weight: bold; margin-bottom: 10px; color: #e67e22; }
    </style>
</head>
<body>

<div class="container">
    <h1>Victron Monitor</h1>
    
    <input type="text" id="keyInput" placeholder="Paste Encryption Key (Hex)" />
    <input type="number" id="limitInput" placeholder="Alert Limit % (e.g., 50)" value="50" />
    
    <button id="connectBtn">Connect to Device</button>
    
    <div class="status" id="statusMsg">Ready to connect</div>
    <div class="soc-display" id="socValue">--%</div>
    
    <div class="log" id="logBox"></div>
</div>

<script>
    const VICTRON_MANUFACTURER_ID = 0x02E1; // 737 decimal
    let encryptionKey = null;
    let alertLimit = 50;
    let lastNotified = false;

    const logBox = document.getElementById('logBox');
    const statusMsg = document.getElementById('statusMsg');
    const socValue = document.getElementById('socValue');

    function log(msg) {
        const d = new Date();
        logBox.innerHTML = `[${d.toLocaleTimeString()}] ${msg}<br>` + logBox.innerHTML;
    }

    function hexToBytes(hex) {
        for (var bytes = [], c = 0; c < hex.length; c += 2)
            bytes.push(parseInt(hex.substr(c, 2), 16));
        return new Uint8Array(bytes);
    }

    document.getElementById('connectBtn').addEventListener('click', async () => {
        const keyHex = document.getElementById('keyInput').value.trim();
        alertLimit = document.getElementById('limitInput').value;

        if (keyHex.length !== 32) {
            alert("Please enter a valid 32-character Hex Key.");
            return;
        }

        // Request Notification Permission
        if (Notification.permission !== "granted") {
            await Notification.requestPermission();
        }

        try {
            // Import Key for Crypto
            const keyBytes = hexToBytes(keyHex);
            encryptionKey = await window.crypto.subtle.importKey(
                "raw", keyBytes, { name: "AES-CTR" }, false, ["decrypt"]
            );

            statusMsg.innerText = "Scanning...";
            
            // Request Bluetooth Device
            // Note: We use acceptAllDevices because Victron sometimes doesn't advertise the Service UUID immediately in the main packet
            const device = await navigator.bluetooth.requestDevice({
                acceptAllDevices: false,
                filters: [{ namePrefix: 'Victron' }, { namePrefix: 'Smart' }, { namePrefix: 'Blue' }],
                optionalManufacturerData: [VICTRON_MANUFACTURER_ID]
            });

            statusMsg.innerText = "Connected! Waiting for data...";
            log(`Device selected: ${device.name}`);

            device.addEventListener('advertisementreceived', (event) => {
                handleAdvertisement(event);
            });

            // Start watching advertisements (passive scanning)
            await device.watchAdvertisements();
            log("Watching for advertisements...");

        } catch (error) {
            log("Error: " + error);
            statusMsg.innerText = "Error connecting.";
        }
    });

    async function handleAdvertisement(event) {
        const manufacturerData = event.manufacturerData;
        if (!manufacturerData) return;

        const victronData = manufacturerData.get(VICTRON_MANUFACTURER_ID);
        if (!victronData) return;

        // Convert DataView to Uint8Array
        const data = new Uint8Array(victronData.buffer);

        // Check Record Type (0x10 = Encrypted)
        if (data[0] !== 0x10) return;

        try {
            await decryptAndParse(data);
        } catch (e) {
            log("Decryption err: " + e);
        }
    }

    async function decryptAndParse(data) {
        // Data Structure:
        // 0: 0x10
        // 1-2: Model ID
        // 3: Readout Type
        // 4-5: IV (Nonce low bytes)
        // 6: Key Check byte
        // 7..n: Encrypted Payload

        // Construct 16-byte Nonce (IV) for AES-CTR
        // Victron Nonce: [Model_L, Model_H, ReadoutType, 0x00, IV_L, IV_H, 0x00... (padding)]
        const nonce = new Uint8Array(16);
        nonce[0] = data[1]; // Model L
        nonce[1] = data[2]; // Model H
        nonce[2] = data[3]; // Readout Type
        nonce[3] = 0x00;    // Padding
        nonce[4] = data[4]; // IV L
        nonce[5] = data[5]; // IV H
        // Rest are 0x00

        const encryptedPayload = data.slice(7); // Data starts at byte 7

        const decryptedBuffer = await window.crypto.subtle.decrypt(
            {
                name: "AES-CTR",
                counter: nonce,
                length: 64 // AES-CTR block size
            },
            encryptionKey,
            encryptedPayload
        );

        const decrypted = new Uint8Array(decryptedBuffer);
        
        // Attempt to read SOC
        // Note: SOC location varies by model. For SmartShunt it is usually bytes 12-13 (Little Endian)
        // If this displays garbage, the offset might be different.
        // Common offsets: 12 (SmartShunt), 10 (Some MPPTs)
        
        // Safety check length
        if (decrypted.length < 14) return;

        // Read 16-bit unsigned integer at offset 12
        let socRaw = decrypted[12] | (decrypted[13] << 8);
        
        // Apply mask (0x3FFF) and scale (0.1)
        // Some models use 0x7FFF for invalid
        if (socRaw === 0x7FFF || socRaw === 0xFFFF) return; // Invalid data

        let soc = (socRaw & 0x3FFF) * 0.1; // 0.1% steps
        let socFixed = soc.toFixed(1);

        // Update UI
        socValue.innerText = `${socFixed}%`;
        statusMsg.innerText = "Monitoring active";
        
        // Notification Logic
        if (soc < alertLimit && !lastNotified) {
            sendNotification(socFixed);
            lastNotified = true; // Prevent spam
        } else if (soc > alertLimit + 5) {
            lastNotified = false; // Reset if charged back up
        }
    }

    function sendNotification(val) {
        log(`ALERT: SOC is ${val}%`);
        if (Notification.permission === "granted") {
            new Notification("Battery Alert!", {
                body: `Battery SOC is critical: ${val}%`,
                icon: "https://via.placeholder.com/128?text=!"
            });
            
            // Also try to vibrate
            if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
        }
    }
</script>

</body>
</html>

